<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–í–∏–¥–µ–æ—á–∞—Ç–†–ö</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body, html {
        margin: 0;
        padding: 0;
        background: black;
        overflow: hidden;
        font-family: Arial, sans-serif;
    }
    /* –û—Å–Ω–æ–≤–Ω–æ–µ –≤–∏–¥–µ–æ */
    #mainContainer {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: black;
    }
    #mainVideo {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    /* –ú–∏–Ω–∏–∞—Ç—é—Ä–∞ */
    #miniContainer {
        position: fixed;
        bottom: 100px;
        right: 20px;
        width: 200px;
        height: 150px;
        border: 2px solid red;
        background: black;
        border-radius: 8px;
        overflow: hidden;
        z-index: 10;
        cursor: move;
        touch-action: none;
    }
    #miniVideo {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    /* –ü–∞–Ω–µ–ª—å –∫–Ω–æ–ø–æ–∫ */
    .controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        z-index: 20;
    }
    .btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        color: white;
        background: rgba(50,50,50,0.7);
    }
    .btn.red { background: red; }
    .btn:active { transform: scale(0.9); }
</style>
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
</head>
<body>

<div id="mainContainer">
    <video id="mainVideo" autoplay playsinline></video>
</div>

<div id="miniContainer">
    <video id="miniVideo" autoplay playsinline muted></video>
</div>

<div class="controls">
    <button id="btnMic" class="btn">üé§</button>
    <button id="btnCam" class="btn">üì∑</button>
    <button id="btnSwitch" class="btn">üîÑ</button>
    <button id="btnEnd" class="btn red">üìû</button>
</div>

<script>
const socket = io('https://videoc-hatrk-server.onrender.com');
let localStream, remoteStream, peerConnection;
let isMicOn = true, isCamOn = true;
let usingFrontCam = true;

const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

async function startLocalStream() {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: usingFrontCam ? "user" : "environment" },
            audio: true 
        });
        document.getElementById('miniVideo').srcObject = localStream;
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–µ–¥–∏–∞:', error);
    }
}

async function createPeerConnection() {
    peerConnection = new RTCPeerConnection(config);
    if (localStream) {
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
    }
    peerConnection.ontrack = event => {
        const mainVid = document.getElementById('mainVideo');
        mainVid.srcObject = event.streams[0];
    };
    peerConnection.onicecandidate = event => {
        if (event.candidate) socket.emit('ice-candidate', event.candidate);
    };
}

socket.on('offer', async offer => {
    if (!peerConnection) await createPeerConnection();
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    socket.emit('answer', answer);
});

socket.on('answer', async answer => {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
});

socket.on('ice-candidate', async candidate => {
    try {
        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ ICE:', error);
    }
});

async function createOffer() {
    if (!peerConnection) await createPeerConnection();
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    socket.emit('offer', offer);
}

startLocalStream().then(() => setTimeout(createOffer, 2000));

/* –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –º–∏–Ω–∏–∞—Ç—é—Ä—ã + —Å–º–µ–Ω–∞ –º–µ—Å—Ç */
(function enableMiniatureControls() {
    const mini = document.getElementById("miniContainer");
    const mainVideo = document.getElementById("mainVideo");
    const miniVideo = document.getElementById("miniVideo");
    let isDragging = false, offsetX = 0, offsetY = 0;

    function startDrag(x, y) {
        isDragging = true;
        offsetX = x - mini.getBoundingClientRect().left;
        offsetY = y - mini.getBoundingClientRect().top;
        mini.style.transition = "none";
    }
    function dragMove(x, y) {
        if (!isDragging) return;
        mini.style.left = `${x - offsetX}px`;
        mini.style.top = `${y - offsetY}px`;
    }
    function endDrag() {
        isDragging = false;
        mini.style.transition = "all 0.2s";
    }

    // –ú—ã—à—å
    mini.addEventListener("mousedown", e => startDrag(e.clientX, e.clientY));
    document.addEventListener("mousemove", e => dragMove(e.clientX, e.clientY));
    document.addEventListener("mouseup", endDrag);

    // –°–µ–Ω—Å–æ—Ä
    mini.addEventListener("touchstart", e => {
        const t = e.touches[0];
        startDrag(t.clientX, t.clientY);
    }, { passive: true });
    document.addEventListener("touchmove", e => {
        const t = e.touches[0];
        dragMove(t.clientX, t.clientY);
    }, { passive: true });
    document.addEventListener("touchend", endDrag);

    // –°–º–µ–Ω–∞ –º–µ—Å—Ç
    mini.addEventListener("click", () => {
        const temp = mainVideo.srcObject;
        mainVideo.srcObject = miniVideo.srcObject;
        miniVideo.srcObject = temp;
    });
})();

/* –ö–Ω–æ–ø–∫–∏ */
document.getElementById('btnMic').addEventListener('click', () => {
    isMicOn = !isMicOn;
    localStream.getAudioTracks().forEach(track => track.enabled = isMicOn);
});
document.getElementById('btnCam').addEventListener('click', () => {
    isCamOn = !isCamOn;
    localStream.getVideoTracks().forEach(track => track.enabled = isCamOn);
});
document.getElementById('btnSwitch').addEventListener('click', async () => {
    usingFrontCam = !usingFrontCam;
    const videoTrack = (await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: usingFrontCam ? "user" : "environment" }
    })).getVideoTracks()[0];
    const sender = peerConnection.getSenders().find(s => s.track.kind === 'video');
    sender.replaceTrack(videoTrack);
    localStream.removeTrack(localStream.getVideoTracks()[0]);
    localStream.addTrack(videoTrack);
    document.getElementById('miniVideo').srcObject = localStream;
});
document.getElementById('btnEnd').addEventListener('click', () => {
    if (peerConnection) peerConnection.close();
    if (localStream) localStream.getTracks().forEach(track => track.stop());
    window.location.reload();
});
</script>

</body>
</html>
